
排序算法总结
       平均时间复杂度         原地排序            额外空间             是否稳定

插入排序   O(n^2)             是                O(1)                 是
归并排序   O(n*log n)        不是               O(n) 需要临时数组安间   是
快速排序   O(n*log n)         是                O(log n)             不是
堆排序     O(n*log n)         是                O(1)                 不是


稳定排序：
    对于相等的元素，在排序后，它们的相对位置没有发生变化； 即 之前排在前的依然排前，排之后的依然排后
    详细的说：有重复的元素，在排序后，这些元素它们原来的相对位置是没有变化的，谁在前在后，没有改变。

稳定性与具体实现是相关，若比较相等时，就要反向置换，那肯定就可以破坏其稳定性

也可以自定义比较方法，保持稳定性
    例如，有一组学生成绩数据，它们以学生姓名排好序了，要求再以分数进行排序，最终要求分数相等时，再以姓名排序：
        1. 直接进行稳定排序算法； 因已经姓名排序好了，分数通过稳定排序后，姓名位置还是排序好的。
        2. 非稳定排序算法：添加自定义比较方法
                if (stu1.score - stu2.score > 0) {//>0 前， <0 在后
                    return 0;
                } else if (stu1.score - stu2.score < 0) {
                    return -1;
                } else {
                    return stu1.name.compareTo(stu2.name);
                }